# Cracking the Code Interview 第十三章 C++知识

- 写一个函数打印一个文件的最后K行
    + 用到了环形数组的知识，只需要遍历一遍文件即可
    + ifstream， 文件输入流的用法， ifstream的构造函数， getline函数， close函数， good函数获取状态

- hash表和STL map的区别
    + hash表采用使用hash函数来计算key的存放位置，常数级时间的读取和写入（在没有很多冲突的情况下）
    + STL map采用红黑树来存储 key，value。 存取时间复杂度为 O(log(N)), 元素按照key有序存放。可以方便的找到最大，最小值。
    + hash表的时间性能好， map的空间要求低一些
    + 对于较少的元素，尽管map需要 log(N)的时间，仍然可以使用map来存放，因为对于小的N，logN复杂度几乎为常数时间

- C++ virtual虚函数的工作机制
    + 对于每一个拥有 至少一个virtual函数的类，编译器会为每一个该类的对象加入一个 虚表指针变量， vptr。 这个虚表指针指向了该类的虚函数列表，同时所有的虚函数都在运行时进行符号解析（resolve）。
        当基类的指针指向子类的对象时， 基类指针的调用虚函数，会被编译器翻译为（找到该对象的vptr, 并调用该vtpr指向的虚表中的函数）.
        总之，虚函数的地址都是在运行时确定的， 而非虚函数的地址都是在编译时确定的。

- 解释浅拷贝和深度拷贝
    + 举了一个例子说明，浅拷贝是直接进行指针赋值，让对象的成员指针指向同一个地方。
        深度拷贝是拷贝指针指向的内存的数据，即重新开辟一个内存空间，存放数据。
    + 在实际编程中，很少使用浅拷贝，因为浅拷贝可能会造成一些问题。比如，可能对同一个内存地址多次释放，内存泄漏等。
    + 浅拷贝和深度拷贝都应该是递归定义的
    + memcpy这种函数就是深度拷贝，直接拷贝指向区域的所有二进制数据。

- volatile关键字

- C++中的name hiding
    + name hiding指的是，子类中的同名函数（只需要同名，不管参数和返回值类型）会隐藏掉父类中所有的该同名函数（即便该函数有重载）。
    + 可以使用 using Baseclass::targetFunction; 来抵消name hiding
    + C++ 中name hiding是必要的， 因为没有name hiding在修改父类时，可能造成已经能工作的子类的函数不能正常工作。

- 为什么 父类的 析构函数都要写成 虚函数
    + 编译器自动的在 子类析构函数调用的结尾加入父类析构函数。
    + 如果父类的析构函数不写成虚函数，那么指向子类的父类指针在进行 delete 时，或者引用离开作用域时，将不能正确的调用子类的析构函数释放内存，这通常不是程序员想要的。

- Colone 指向特定树结构或者图结构的指针
    + 与lintcode colone graph题目相类似
    + 使用一个map来存储 <old_ptr, new_ptr>的关系，然后使用广度优先或者深度优先来遍历该结构，如果map中不存在old_ptr，则为new_ptr分配内存。并合理的安排指针的指向

- 写一个 smart_ptr类
    + 一个带有引用计数的模板类，每多一次引用计数加一，少一次引用计数减1，计数减到0时销毁内存
    + 关键是在 复制构造函数中 加引用计数， 在析构函数中减少引用计数，并判断是否销毁内存
    + 可参照书中的源码
